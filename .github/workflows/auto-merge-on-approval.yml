# ------------------------------------------------------------------------------
#  Auto Merge on Approval Workflow
#
#  Purpose: Automatically merge PRs once all approval and CI conditions pass.
#           For first time contributors, we attempt to post a friendly welcome
#           comment, but only when the default GITHUB_TOKEN has write access
#           (i.e., not from forks).
#
#  Triggers: Pull‚Äërequest events, review submissions, and completed checks.
#
#  Maintainer: @mrz1836
#
#  Rules for Auto‚ÄëMerge:
#    ‚Ä¢ ‚â•1 approval review
#    ‚Ä¢ No requested reviewers remaining
#    ‚Ä¢ No "Changes Requested" reviews
#    ‚Ä¢ All required status checks pass:
#        - test (1.24.x, ubuntu-latest) (min version)
#        - Analyze (go)
#    ‚Ä¢ Title must not contain "WIP"
#    ‚Ä¢ PR must not have the "work-in-progress" label
#    ‚Ä¢ PR must not be a draft
# ------------------------------------------------------------------------------

name: auto-merge-on-approval

on:
    pull_request:
        types:
            - opened
            - synchronize
            - reopened
            - ready_for_review
            - labeled
            - unlabeled
            - edited
    pull_request_review:
        types: [submitted]
    check_suite:
        types: [completed]
    status: {}

# Cancel older runs of the same PR if a new commit is pushed
concurrency:
    group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
    cancel-in-progress: true

permissions:
    contents: read
    pull-requests: read
    issues: read

jobs:
    automerge:
        runs-on: ubuntu-latest
        permissions:
            pull-requests: write     # needed to merge PRs
            issues: write            # needed to comment on PRs

        steps:
            - name: Attempt auto‚Äëmerge
              uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
              with:
                  github-token: ${{ secrets.GITHUB_TOKEN }}
                  script: |
                      const owner = context.repo.owner;
                      const repo  = context.repo.repo;

                      // ------------------------------------------------------------
                      // Helper ‚Äì locate the PR, even for check_suite/status events
                      // ------------------------------------------------------------
                      async function findPullRequest() {
                        if (context.payload.pull_request) {
                          return context.payload.pull_request;
                        }
                        const sha = context.payload.check_suite?.head_sha || context.payload.sha;
                        if (!sha) return null;
                        const { data: prs } = await github.rest.pulls.list({
                          owner,
                          repo,
                          head: `${owner}:${sha}`,
                          state: 'open',
                        });
                        return prs[0] || null;
                      }

                      const pr = await findPullRequest();
                      if (!pr) {
                        core.info('PR not found (may be closed); exiting.');
                        return;
                      }

                      const prNumber   = pr.number;
                      const prAuthor   = pr.user.login;
                      const isFromFork = pr.head.repo.full_name !== `${owner}/${repo}`;

                      // ------------------------------------------------------------
                      // Welcome comment for first‚Äëtime contributors (if possible)
                      // ------------------------------------------------------------
                      const firstTime = ['FIRST_TIMER', 'FIRST_TIME_CONTRIBUTOR'].includes(pr.author_association);
                      if (firstTime && !isFromFork) {
                        try {
                          await github.rest.issues.createComment({
                            owner,
                            repo,
                            issue_number: prNumber,
                            body: `üëã **Welcome @${prAuthor}!** Thanks for your first contribution. A maintainer will review your PR shortly.`
                          });
                          core.info(`Posted welcome comment to PR #${prNumber}.`);
                        } catch (error) {
                          core.warning(`Unable to post welcome comment: ${error.message}`);
                        }
                      } else if (firstTime && isFromFork) {
                        core.info('Skipping welcome comment for fork PR due to read‚Äëonly GITHUB_TOKEN.');
                      }

                      // ------------------------------------------------------------
                      // Gather PR metadata
                      // ------------------------------------------------------------
                      const title    = pr.title || '';
                      const labels   = pr.labels.map(l => l.name);
                      const isDraft  = pr.draft;

                      // Reviews
                      const { data: reviews } = await github.rest.pulls.listReviews({
                        owner,
                        repo,
                        pull_number: prNumber,
                      });
                      const approvals        = reviews.filter(r => r.state === 'APPROVED').length;
                      const changesRequested = reviews.filter(r => r.state === 'CHANGES_REQUESTED').length;

                      // Requested reviewers
                      const requestedReviewers = pr.requested_reviewers || [];

                      // Required checks
                      const requiredChecks = [
                        'test (1.24.x, ubuntu-latest)',
                        'Analyze (go)',
                      ];
                      const sha = pr.head.sha;
                      const { data: checks } = await github.rest.checks.listForRef({
                        owner,
                        repo,
                        ref: sha,
                      });
                      const checkRuns = checks.check_runs || [];
                      const checksPass = requiredChecks.every(name => {
                        const run = checkRuns.find(c => c.name === name);
                        return run && run.conclusion === 'success';
                      });

                      // WIP indicators
                      const titleHasWip = /wip/i.test(title);
                      const hasWipLabel = labels.includes('work-in-progress');

                      // ------------------------------------------------------------
                      // Merge or log reasons why we cannot yet merge
                      // ------------------------------------------------------------
                      const canMerge = approvals >= 1 &&
                                       requestedReviewers.length === 0 &&
                                       changesRequested === 0 &&
                                       checksPass &&
                                       !titleHasWip &&
                                       !hasWipLabel &&
                                       !isDraft;

                      if (canMerge) {
                        try {
                          await github.rest.pulls.merge({
                            owner,
                            repo,
                            pull_number: prNumber,
                            merge_method: 'merge',
                          });
                          core.info(`‚úÖ Pull request #${prNumber} merged.`);
                        } catch (error) {
                          core.warning(`‚ùå Failed to merge PR #${prNumber}: ${error.message}`);
                        }
                      } else {
                        if (approvals < 1)          core.info('‚ÑπÔ∏è  Waiting for at least one approval.');
                        if (requestedReviewers.length) core.info('‚ÑπÔ∏è  Waiting for requested reviewers.');
                        if (changesRequested)       core.info('‚ÑπÔ∏è  Change requests still present.');
                        if (!checksPass)            core.info('‚ÑπÔ∏è  Required checks not yet successful.');
                        if (titleHasWip)            core.info('‚ÑπÔ∏è  Title contains "WIP".');
                        if (hasWipLabel)            core.info('‚ÑπÔ∏è  "work-in-progress" label present.');
                        if (isDraft)                core.info('‚ÑπÔ∏è  PR is a draft.');
                      }
